"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PusherMember = exports.PusherEvent = exports.PusherChannel = exports.Pusher = void 0;
var _reactNative = require("react-native");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
const LINKING_ERROR = `The package 'pusher-websocket-react-native' doesn't seem to be linked. Make sure: \n\n` + _reactNative.Platform.select({
  ios: "- You have run 'pod install'\n",
  default: ''
}) + '- You rebuilt the app after installing the package\n' + '- You are not using Expo managed workflow\n';
const PusherWebsocketReactNative = _reactNative.NativeModules.PusherWebsocketReactNative ? _reactNative.NativeModules.PusherWebsocketReactNative : new Proxy({}, {
  get() {
    throw new Error(LINKING_ERROR);
  }
});
var PusherEventName;
(function (PusherEventName) {
  PusherEventName["ON_AUTHORIZER"] = "PusherReactNative:onAuthorizer";
  PusherEventName["ON_CONNECTION_STATE_CHANGE"] = "PusherReactNative:onConnectionStateChange";
  PusherEventName["ON_SUBSCRIPTION_ERROR"] = "PusherReactNative:onSubscriptionError";
  PusherEventName["ON_EVENT"] = "PusherReactNative:onEvent";
  PusherEventName["ON_ERROR"] = "PusherReactNative:onError";
  PusherEventName["ON_MEMBER_ADDED"] = "PusherReactNative:onMemberAdded";
  PusherEventName["ON_MEMBER_REMOVED"] = "PusherReactNative:onMemberRemoved";
})(PusherEventName || (PusherEventName = {}));
class PusherEvent {
  constructor(args) {
    _defineProperty(this, "channelName", void 0);
    _defineProperty(this, "eventName", void 0);
    _defineProperty(this, "data", void 0);
    _defineProperty(this, "userId", void 0);
    this.channelName = args.channelName;
    this.eventName = args.eventName;
    this.data = args.data;
    this.userId = args.userId;
  }
  toString() {
    return `{ channelName: ${this.channelName}, eventName: ${this.eventName}, data: ${this.data}, userId: ${this.userId} }`;
  }
}
exports.PusherEvent = PusherEvent;
class PusherMember {
  constructor(userId, userInfo) {
    _defineProperty(this, "userId", void 0);
    _defineProperty(this, "userInfo", void 0);
    this.userId = userId;
    this.userInfo = userInfo;
  }
  toString() {
    return `{ userId: ${this.userId}, userInfo: ${JSON.stringify(this.userInfo)} }`;
  }
}
exports.PusherMember = PusherMember;
class PusherChannel {
  constructor(args) {
    _defineProperty(this, "channelName", void 0);
    _defineProperty(this, "members", new Map());
    _defineProperty(this, "me", void 0);
    _defineProperty(this, "subscriptionCount", void 0);
    _defineProperty(this, "onSubscriptionSucceeded", void 0);
    _defineProperty(this, "onSubscriptionCount", void 0);
    _defineProperty(this, "onEvent", void 0);
    _defineProperty(this, "onMemberAdded", void 0);
    _defineProperty(this, "onMemberRemoved", void 0);
    this.channelName = args.channelName;
    this.onSubscriptionSucceeded = args.onSubscriptionSucceeded;
    this.onEvent = args.onEvent;
    this.onMemberAdded = args.onMemberAdded;
    this.onMemberRemoved = args.onMemberRemoved;
    this.onSubscriptionCount = args.onSubscriptionCount;
    this.me = args.me;
  }
  async unsubscribe() {
    return Pusher.getInstance().unsubscribe({
      channelName: this.channelName
    });
  }
  async trigger(event) {
    if (event.channelName !== this.channelName) {
      throw 'Event is not for this channel';
    }
    return Pusher.getInstance().trigger(event);
  }
}
exports.PusherChannel = PusherChannel;
class Pusher {
  constructor() {
    _defineProperty(this, "pusherEventEmitter", new _reactNative.NativeEventEmitter(PusherWebsocketReactNative));
    _defineProperty(this, "channels", new Map());
    _defineProperty(this, "connectionState", 'DISCONNECTED');
  }
  static getInstance() {
    if (!Pusher.instance) {
      Pusher.instance = new Pusher();
    }
    return Pusher.instance;
  }
  addListener(pusherEventName, callback) {
    return this.pusherEventEmitter.addListener(pusherEventName, callback);
  }
  init(args) {
    this.removeAllListeners();
    this.addListener(PusherEventName.ON_CONNECTION_STATE_CHANGE, event => {
      var _args$onConnectionSta;
      this.connectionState = event.currentState.toUpperCase();
      (_args$onConnectionSta = args.onConnectionStateChange) === null || _args$onConnectionSta === void 0 ? void 0 : _args$onConnectionSta.call(args, event.currentState.toUpperCase(), event.previousState.toUpperCase());
    });
    this.addListener(PusherEventName.ON_ERROR, event => {
      var _args$onError;
      return (_args$onError = args.onError) === null || _args$onError === void 0 ? void 0 : _args$onError.call(args, event.message, event.code, event.error);
    });
    this.addListener(PusherEventName.ON_EVENT, event => {
      var _args$onSubscriptionS, _channel$onSubscripti, _args$onSubscriptionC, _channel$onSubscripti2, _args$onEvent, _channel$onEvent;
      const channelName = event.channelName;
      const eventName = event.eventName;
      const data = event.data;
      const userId = event.userId;
      const channel = this.channels.get(channelName);
      switch (eventName) {
        case 'pusher_internal:subscription_succeeded':
          // Depending on the platform implementation we get json or a Map.
          var decodedData = data instanceof Object ? data : JSON.parse(data);
          for (const _userId in (_decodedData = decodedData) === null || _decodedData === void 0 ? void 0 : (_decodedData$presence = _decodedData.presence) === null || _decodedData$presence === void 0 ? void 0 : _decodedData$presence.hash) {
            var _decodedData, _decodedData$presence, _decodedData2, _decodedData2$presenc;
            const userInfo = (_decodedData2 = decodedData) === null || _decodedData2 === void 0 ? void 0 : (_decodedData2$presenc = _decodedData2.presence) === null || _decodedData2$presenc === void 0 ? void 0 : _decodedData2$presenc.hash[_userId];
            var member = new PusherMember(_userId, userInfo);
            channel === null || channel === void 0 ? void 0 : channel.members.set(member.userId, member);
            if (_userId === userId && channel) {
              channel.me = member;
            }
          }
          (_args$onSubscriptionS = args.onSubscriptionSucceeded) === null || _args$onSubscriptionS === void 0 ? void 0 : _args$onSubscriptionS.call(args, channelName, decodedData);
          channel === null || channel === void 0 ? void 0 : (_channel$onSubscripti = channel.onSubscriptionSucceeded) === null || _channel$onSubscripti === void 0 ? void 0 : _channel$onSubscripti.call(channel, decodedData);
          break;
        case 'pusher_internal:subscription_count':
          // Depending on the platform implementation we get json or a Map.
          var decodedData = data instanceof Object ? data : JSON.parse(data);
          if (channel) {
            channel.subscriptionCount = decodedData.subscription_count;
          }
          (_args$onSubscriptionC = args.onSubscriptionCount) === null || _args$onSubscriptionC === void 0 ? void 0 : _args$onSubscriptionC.call(args, channelName, decodedData.subscription_count);
          channel === null || channel === void 0 ? void 0 : (_channel$onSubscripti2 = channel.onSubscriptionCount) === null || _channel$onSubscripti2 === void 0 ? void 0 : _channel$onSubscripti2.call(channel, decodedData.subscription_count);
          break;
        default:
          const pusherEvent = new PusherEvent(event);
          (_args$onEvent = args.onEvent) === null || _args$onEvent === void 0 ? void 0 : _args$onEvent.call(args, pusherEvent);
          channel === null || channel === void 0 ? void 0 : (_channel$onEvent = channel.onEvent) === null || _channel$onEvent === void 0 ? void 0 : _channel$onEvent.call(channel, pusherEvent);
          break;
      }
    });
    this.addListener(PusherEventName.ON_MEMBER_ADDED, event => {
      var _args$onMemberAdded, _channel$onMemberAdde;
      const user = event.user;
      const channelName = event.channelName;
      var member = new PusherMember(user.userId, user.userInfo);
      const channel = this.channels.get(channelName);
      channel === null || channel === void 0 ? void 0 : channel.members.set(member.userId, member);
      (_args$onMemberAdded = args.onMemberAdded) === null || _args$onMemberAdded === void 0 ? void 0 : _args$onMemberAdded.call(args, channelName, member);
      channel === null || channel === void 0 ? void 0 : (_channel$onMemberAdde = channel.onMemberAdded) === null || _channel$onMemberAdde === void 0 ? void 0 : _channel$onMemberAdde.call(channel, member);
    });
    this.addListener(PusherEventName.ON_MEMBER_REMOVED, event => {
      var _args$onMemberRemoved, _channel$onMemberRemo;
      const user = event.user;
      const channelName = event.channelName;
      var member = new PusherMember(user.userId, user.userInfo);
      const channel = this.channels.get(channelName);
      channel === null || channel === void 0 ? void 0 : channel.members.delete(member.userId);
      (_args$onMemberRemoved = args.onMemberRemoved) === null || _args$onMemberRemoved === void 0 ? void 0 : _args$onMemberRemoved.call(args, channelName, member);
      channel === null || channel === void 0 ? void 0 : (_channel$onMemberRemo = channel.onMemberRemoved) === null || _channel$onMemberRemo === void 0 ? void 0 : _channel$onMemberRemo.call(channel, member);
    });
    this.addListener(PusherEventName.ON_AUTHORIZER, async _ref => {
      var _args$onAuthorizer;
      let {
        channelName,
        socketId
      } = _ref;
      const data = await ((_args$onAuthorizer = args.onAuthorizer) === null || _args$onAuthorizer === void 0 ? void 0 : _args$onAuthorizer.call(args, channelName, socketId));
      if (data) {
        await PusherWebsocketReactNative.onAuthorizer(channelName, socketId, data);
      }
    });
    this.addListener(PusherEventName.ON_SUBSCRIPTION_ERROR, async _ref2 => {
      var _args$onSubscriptionE;
      let {
        channelName,
        message,
        type
      } = _ref2;
      (_args$onSubscriptionE = args.onSubscriptionError) === null || _args$onSubscriptionE === void 0 ? void 0 : _args$onSubscriptionE.call(args, channelName, message, type);
    });
    return PusherWebsocketReactNative.initialize({
      apiKey: args.apiKey,
      cluster: args.cluster,
      authEndpoint: args.authEndpoint,
      useTLS: args.useTLS,
      activityTimeout: args.activityTimeout,
      pongTimeout: args.pongTimeout,
      maxReconnectionAttempts: args.maxReconnectionAttempts,
      maxReconnectGapInSeconds: args.maxReconnectGapInSeconds,
      authorizerTimeoutInSeconds: args.authorizerTimeoutInSeconds,
      authorizer: args.onAuthorizer ? true : false,
      proxy: args.proxy
    });
  }
  async connect() {
    return await PusherWebsocketReactNative.connect();
  }
  async disconnect() {
    return await PusherWebsocketReactNative.disconnect();
  }
  unsubscribeAllChannels() {
    const channelsCopy = new Map(this.channels);
    channelsCopy.forEach(channel => {
      this.unsubscribe({
        channelName: channel.channelName
      });
    });
  }
  removeAllListeners() {
    this.pusherEventEmitter.removeAllListeners(PusherEventName.ON_AUTHORIZER);
    this.pusherEventEmitter.removeAllListeners(PusherEventName.ON_ERROR);
    this.pusherEventEmitter.removeAllListeners(PusherEventName.ON_EVENT);
    this.pusherEventEmitter.removeAllListeners(PusherEventName.ON_MEMBER_ADDED);
    this.pusherEventEmitter.removeAllListeners(PusherEventName.ON_MEMBER_REMOVED);
  }
  async reset() {
    this.removeAllListeners();
    this.unsubscribeAllChannels();
  }
  async subscribe(args) {
    const channel = this.channels.get(args.channelName);
    if (channel) {
      return channel;
    }
    const newChannel = new PusherChannel(args);
    await PusherWebsocketReactNative.subscribe(args.channelName);
    this.channels.set(args.channelName, newChannel);
    return newChannel;
  }
  async unsubscribe(_ref3) {
    let {
      channelName
    } = _ref3;
    await PusherWebsocketReactNative.unsubscribe(channelName);
    this.channels.delete(channelName);
  }
  async trigger(event) {
    if (event.channelName.startsWith('private-') || event.channelName.startsWith('presence-')) {
      await PusherWebsocketReactNative.trigger(event.channelName, event.eventName, event.data);
    } else {
      throw 'Trigger event is only for private/presence channels';
    }
  }
  async getSocketId() {
    return await PusherWebsocketReactNative.getSocketId();
  }
  getChannel(channelName) {
    return this.channels.get(channelName);
  }
}
exports.Pusher = Pusher;
_defineProperty(Pusher, "instance", void 0);
//# sourceMappingURL=index.js.map