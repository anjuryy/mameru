export interface PusherAuthorizerResult {
    /** required for private channels */
    auth?: string;
    /** required for encrypted channels */
    shared_secret?: string;
    /** required for presence channels, should be stringified JSON */
    channel_data?: string;
}
export declare class PusherEvent {
    channelName: string;
    eventName: string;
    data: any;
    userId?: string;
    constructor(args: {
        channelName: string;
        eventName: string;
        data: any;
        userId?: string;
    });
    toString(): string;
}
export declare class PusherMember {
    userId: string;
    userInfo: any;
    constructor(userId: string, userInfo: any);
    toString(): string;
}
export declare class PusherChannel {
    channelName: string;
    members: Map<String, PusherMember>;
    me?: PusherMember;
    subscriptionCount?: Number;
    onSubscriptionSucceeded?: (data: any) => void;
    onSubscriptionCount?: (subscriptionCount: Number) => void;
    onEvent?: (event: any) => void;
    onMemberAdded?: (member: PusherMember) => void;
    onMemberRemoved?: (member: PusherMember) => void;
    constructor(args: {
        channelName: string;
        onSubscriptionSucceeded?: (data: any) => void;
        onSubscriptionCount?: (subscriptionCount: Number) => void;
        onEvent?: (member: PusherEvent) => void;
        onMemberAdded?: (member: PusherMember) => void;
        onMemberRemoved?: (member: PusherMember) => void;
        me?: PusherMember;
    });
    unsubscribe(): Promise<void>;
    trigger(event: PusherEvent): Promise<void>;
}
export declare class Pusher {
    private static instance;
    private pusherEventEmitter;
    channels: Map<String, PusherChannel>;
    connectionState: string;
    private constructor();
    static getInstance(): Pusher;
    private addListener;
    init(args: {
        apiKey: string;
        cluster: string;
        authEndpoint?: string;
        useTLS?: boolean;
        activityTimeout?: Number;
        pongTimeout?: Number;
        maxReconnectionAttempts?: Number;
        maxReconnectGapInSeconds?: Number;
        authorizerTimeoutInSeconds?: Number;
        proxy?: string;
        onConnectionStateChange?: (currentState: string, previousState: string) => void;
        onAuthorizer?: (channelName: string, socketId: string) => Promise<PusherAuthorizerResult>;
        onError?: (message: string, code: Number, e: any) => void;
        onEvent?: (event: PusherEvent) => void;
        onSubscriptionSucceeded?: (channelName: string, data: any) => void;
        onSubscriptionError?: (channelName: string, message: string, e: any) => void;
        onSubscriptionCount?: (channelName: string, subscriptionCount: Number) => void;
        onDecryptionFailure?: (eventName: string, reason: string) => void;
        onMemberAdded?: (channelName: string, member: PusherMember) => void;
        onMemberRemoved?: (channelName: string, member: PusherMember) => void;
    }): any;
    connect(): Promise<any>;
    disconnect(): Promise<any>;
    private unsubscribeAllChannels;
    private removeAllListeners;
    reset(): Promise<void>;
    subscribe(args: {
        channelName: string;
        onSubscriptionSucceeded?: (data: any) => void;
        onSubscriptionError?: (channelName: string, message: string, e: any) => void;
        onMemberAdded?: (member: PusherMember) => void;
        onMemberRemoved?: (member: PusherMember) => void;
        onEvent?: (event: PusherEvent) => void;
    }): Promise<PusherChannel>;
    unsubscribe({ channelName }: {
        channelName: string;
    }): Promise<void>;
    trigger(event: PusherEvent): Promise<void>;
    getSocketId(): Promise<any>;
    getChannel(channelName: string): PusherChannel | undefined;
}
//# sourceMappingURL=index.d.ts.map